"""Streamlit prototype dashboard for uploading interviews and viewing reports."""

from __future__ import annotations

import os
import time
from typing import Any, Dict

import httpx
import streamlit as st


def _default_api_base() -> str:
    return os.getenv("NEXT_PUBLIC_API_BASE_URL", "http://localhost:8000/api")


def upload_video(
    api_base: str,
    file_bytes: bytes,
    filename: str,
    mime_type: str | None,
    candidate_id: str | None,
    expected_answer: str,
) -> Dict[str, Any]:
    data: Dict[str, Any] = {"expected_answer": expected_answer}
    if candidate_id:
        data["candidate_id"] = candidate_id

    files = {"file": (filename, file_bytes, mime_type or "application/octet-stream")}
    with httpx.Client(timeout=120) as client:
        response = client.post(f"{api_base}/interviews/upload", data=data, files=files)
        response.raise_for_status()
        return response.json()


def fetch_result(api_base: str, interview_id: str) -> Dict[str, Any]:
    with httpx.Client(timeout=60) as client:
        response = client.get(f"{api_base}/interviews/result/{interview_id}")
        response.raise_for_status()
        return response.json()


def poll_until_complete(api_base: str, interview_id: str, timeout: int = 180, interval: int = 5) -> Dict[str, Any]:
    start = time.monotonic()
    with st.spinner("Processing interview…"):
        while True:
            result = fetch_result(api_base, interview_id)
            status = result.get("status")
            if status != "processing":
                return result
            if time.monotonic() - start > timeout:
                return result
            time.sleep(interval)


def render_report(result: Dict[str, Any]) -> None:
    status = result.get("status")
    st.subheader("Processing Status")
    st.info(f"Interview status: **{status}**")

    if status == "failed":
        st.error(result.get("error", "Processing failed"))
        return

    report = result.get("report") or {}
    if not report:
        st.warning("Report not available yet. Try fetching again in a moment.")
        return

    col1, col2, col3, col4 = st.columns(4)
    col1.metric("Final Score", f"{report.get('final_score', 0):.2f}")
    col2.metric("Verbal Score", f"{report.get('verbal_score', 0):.2f}")
    col3.metric("Non-Verbal Score", f"{report.get('non_verbal_score', 0):.2f}")
    col4.metric("Confidence", f"{report.get('confidence', 0):.3f}")

    st.markdown("#### Summary")
    st.write(report.get("summary") or "No summary provided for this session.")

    vision = report.get("vision_metrics") or {}
    st.markdown("#### Vision Metrics")
    metrics_cols = st.columns(3)
    metrics_cols[0].metric("Eye Contact", f"{vision.get('eye_contact_ratio', 0):.2f}")
    metrics_cols[1].metric("Cheating Score", f"{vision.get('cheating_score', 0):.2f}")
    metrics_cols[2].write(
        f"- Phone detected: **{vision.get('phone_detected', False)}**\n"
        f"- Multiple persons: **{vision.get('multi_person', False)}**"
    )

    st.markdown("#### Transcript")
    transcript = report.get("transcript") or ""
    if transcript:
        st.text_area("Model Transcript", value=transcript, height=200)
    else:
        st.info("Transcript not available.")

    with st.expander("Raw JSON"):
        st.json(result)


def main() -> None:
    st.set_page_config(page_title="AI Interview Assessment (Prototype)", layout="wide")
    st.title("AI Interview Assessment – MVP (Streamlit Prototype)")
    st.write(
        "Upload interview videos, trigger the FastAPI pipeline, and inspect the autogenerated report "
        "without leaving this prototype."
    )

    if "last_interview_id" not in st.session_state:
        st.session_state["last_interview_id"] = None

    api_base = st.sidebar.text_input("FastAPI Base URL", _default_api_base())
    poll_enabled = st.sidebar.checkbox("Auto-poll result", value=True)

    with st.form("upload_form", clear_on_submit=True):
        st.subheader("1) Upload Video")
        uploaded_file = st.file_uploader(
            "Select interview video",
            type=["mp4", "webm", "mov", "mkv"],
            help="Maximum recommended duration 5 minutes.",
        )
        candidate_id = st.text_input("Candidate ID (optional)")
        expected_answer = st.text_area(
            "Expected Answer / Prompt (optional)",
            help="Helps the NLP relevance scoring compare against ideal responses.",
        )
        submit = st.form_submit_button("Start Evaluation", use_container_width=True)

    if submit:
        if not uploaded_file:
            st.error("Please attach a video file first.")
        else:
            try:
                st.info("Uploading video…")
                response = upload_video(
                    api_base=api_base,
                    file_bytes=uploaded_file.read(),
                    filename=uploaded_file.name,
                    mime_type=uploaded_file.type,
                    candidate_id=candidate_id or None,
                    expected_answer=expected_answer,
                )
                interview_id = response["interview_id"]
                st.session_state["last_interview_id"] = interview_id
                st.success(f"Job queued successfully! Interview ID: {interview_id}")
                if poll_enabled:
                    result = poll_until_complete(api_base, interview_id)
                    render_report(result)
            except httpx.HTTPStatusError as exc:
                st.error(f"Upload failed: {exc.response.text}")
            except Exception as exc:  # noqa: BLE001
                st.exception(exc)

    st.divider()
    st.subheader("2) Fetch Latest Report")
    interview_id_input = st.text_input(
        "Interview ID",
        value=st.session_state.get("last_interview_id") or "",
        help="Use the ID returned after an upload.",
    )
    if st.button("Fetch Result", use_container_width=True):
        if not interview_id_input:
            st.warning("Provide an interview ID first.")
        else:
            try:
                result = fetch_result(api_base, interview_id_input)
                render_report(result)
            except httpx.HTTPStatusError as exc:
                st.error(f"Backend error: {exc.response.text}")
            except Exception as exc:  # noqa: BLE001
                st.exception(exc)


if __name__ == "__main__":
    main()
